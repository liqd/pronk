{-# LANGUAGE BangPatterns, RecordWildCards, OverloadedStrings, NoImplicitPrelude #-}

module Network.HTTP.LoadTest
    (
    -- * Running a load test
      NetworkError(..)
    , Config(..)
    , Req(..)
    , RequestGenerator(..)
    , defaultConfig
    , run
    , timed
    ) where

import Control.Applicative ((<$>))
import Control.Concurrent (forkIO, threadDelay)
import Control.Concurrent.Chan (newChan, readChan, writeChan)
import Control.Concurrent.MVar (newEmptyMVar, takeMVar, putMVar)
import Control.Exception (finally)
import Control.Exception.Lifted (catch, throwIO, try)
import Control.Monad (forM_, replicateM, when)
import Control.Monad.Trans.Resource (runResourceT)
import Data.Either (partitionEithers)
import Data.List (nub)
import Data.Time.Clock.POSIX (POSIXTime, getPOSIXTime)
import Data.Text (Text)
import qualified Data.Text.Format as T
import Network.HTTP.Conduit
import Network.HTTP.LoadTest.Types
import Network.HTTP.LoadTest.Report (buildTime)
import qualified Data.ByteString.Lazy as L
import qualified Data.Vector as V
import qualified Data.Vector.Algorithms.Intro as I
import qualified Data.Vector.Generic as G
import System.CPUTime (getCPUTime)
import qualified System.Timeout.Lifted as T
import Control.Monad.IO.Class (liftIO)
import Control.Monad.Trans.Resource (ResourceT)
import qualified Network.HTTP.Types as H
import System.Console.CmdArgs (whenNormal)
import Prelude hiding ((<$>))

run :: Config -> IO (Either [NetworkError] (V.Vector Summary))
run cfg@Config{..} = do
  let reqs = zipWith (+) (replicate concurrency reqsPerThread)
                         (replicate leftover 1 ++ repeat 0)
        where (reqsPerThread,leftover) = numRequests `quotRem` concurrency
  let !interval | requestsPerSecond == 0 = 0
                | otherwise = realToFrac (fromIntegral concurrency /
                                          requestsPerSecond)
  ch <- newChan
  forM_ (zip reqs [0..]) $ \(numReqs, rgSelector) -> forkIO $ do
    mgr <- newManager tlsManagerSettings
    let cfg' = cfg { numRequests = numReqs }
    liftIO . writeChan ch =<< (try . runResourceT . client cfg' rgSelector mgr $ interval)
  (errs,vs) <- partitionEithers <$> replicateM concurrency (readChan ch)
  return $ case errs of
             [] -> Right . G.modify I.sort . V.concat $ vs
             _  -> Left (nub errs)

client :: Config -> Int -> Manager -> POSIXTime
       -> ResourceT IO (V.Vector Summary)
client Config{..} rgSelector mgr interval = loop initialRequestGenerator 0 []
  where
    -- if requests are generated by state machine, pick the state to
    -- be used for this thread.
    initialRequestGenerator :: RequestGenerator
    initialRequestGenerator = concat (repeat requests) !! rgSelector

    loop !requestGenerator !n acc
        | n == numRequests = return (V.fromList acc)
        | otherwise = do
      let (req, newRequestGenerator) = case requestGenerator of
            nr@(RequestGeneratorConstant r) -> (r, const nr)
            RequestGeneratorStateMachine name state trans -> case trans state of
                (r, s) -> (r, \ resp -> RequestGeneratorStateMachine name (s resp) trans)

      now <- liftIO getPOSIXTime
      !(evt, resp) <- timedRequest req
      now' <- (maybe 0 (L.length . responseBody) resp) `seq` liftIO getPOSIXTime

      let elapsed = now' - now
          !s = Summary {
                 summEvent = evt
               , summElapsed = realToFrac elapsed
               , summStart = realToFrac now
               }
      when (elapsed < interval) $
        liftIO . threadDelay . truncate $ (interval - elapsed) * 1000000
      loop (maybe requestGenerator newRequestGenerator resp) (n+1) (s:acc)

    issueRequest :: Req -> ResourceT IO (Response L.ByteString)
    issueRequest req = httpLbs (clear $ fromReq req) mgr
                   `catch` (throwIO . NetworkError)
      where clear r = r { checkStatus = \_ _ _ -> Nothing
                        , responseTimeout = Nothing
                        }
    timedRequest :: Req -> ResourceT IO (Event, Maybe (Response L.ByteString))
    timedRequest req
      | timeout == 0 = respEvent <$> issueRequest req
      | otherwise    = do
      maybeResp <- T.timeout (truncate (timeout * 1e6)) $ issueRequest req
      case maybeResp of
        Just resp -> return $ respEvent resp
        _         -> return (Timeout, Nothing)

timed :: Text -> IO a -> IO (a,Double)
timed desc act = do
  t <- newEmptyMVar
  startCPU <- getCPUTime
  startWall <- getPOSIXTime
  ret <- act `finally` do
    endCPU <- getCPUTime
    endWall <- getPOSIXTime
    let elapsedCPU  = fromIntegral (endCPU - startCPU) / 1e12
        elapsedWall = realToFrac $ endWall - startWall
        ratio = elapsedCPU / elapsedWall
    whenNormal $
      -- Try to work around the 64-bit Mac getCPUTime bug
      -- http://hackage.haskell.org/trac/ghc/ticket/4970
      if ratio > 0 && ratio < 32
      then T.print "{} in {} ({}% CPU)\n"
               (desc, buildTime 4 elapsedWall,
                T.fixed 1 $ 100 * elapsedCPU / elapsedWall)
      else T.print "{} in {}\n"
               (desc, buildTime 4 elapsedWall)
    putMVar t elapsedWall
  ((,) ret) <$> takeMVar t

respEvent :: Response L.ByteString -> (Event, Maybe (Response L.ByteString))
respEvent resp =
    (HttpResponse {
      respCode = H.statusCode $ responseStatus resp
    , respContentLength = fromIntegral . L.length . responseBody $ resp
    }, Just resp)
